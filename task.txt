# Калькулятор бюджета

## Цель проекта: Создать программу, которая покажет, позволяет ли бюджет выполнить ряд задач или нет

### В проекте должно быть:

+ **ООП**:
    + Реализуйте классы:
        + Контроллер бюджета
        + Контроллер задач
        + Задача
        + Прибыльная задача
        + Убыточная задача
    + Наследование:
        + Задача:
            + Прибыльная задача
            + Убыточная задача

### Требования к реализации:

> Названия ниже чисто для примеров, можете подобрать сами, главное чтобы было что-то адекватное
>
> (#) - обозначение приватного поля/метода

+ Ни один из функций конструкторов/классов не может быть вызван без "new" (пока не указано обратное)


+ Класс `Task`
    + Должен быть сделан с помощью функции конструкта
    + Должен быть запрет на создание экземпляра этого класса
    + Должен иметь следующие поля:
        + `(#) id: string` - [уникальный идентификатор](https://stackoverflow.com/a/19842865/13349770)
        + `(#) description: string` - название/описание задачи
        + `(#) cost: number` - стоимость задачи. Допустимые значения: `>= 0`
    + Должен иметь следующие геттеры:
        + `id: () => string`
        + `description: () => string`
        + `cost: () => number`


+ Класс `IncomeTask`
    + Должен наследоваться от класса `Task`
    + Должен иметь следующие методы:
        + `makeDone: (object) => undefined` - на вход принимает объект `(#) budget` и увеличивает его поле `income` на значение `(#) cost`
        + `makeUnDone: (object) => undefined` - на вход принимает объект `(#) budget` и уменьшает его поле `income` на значение `(#) cost`


+ Класс `ExpenseTask`
    + Должен наследоваться от класса `Task`
    + Должен иметь следующие методы:
        + `makeDone: (object) => undefined` - на вход принимает объект `(#) budget` и увеличивает его поле `expenses` на значение `(#) cost`
        + `makeUnDone: (object) => undefined` - на вход принимает объект `(#) budget` и уменьшает его поле `expenses` на значение `(#) cost`


+ Класс `TasksController`
    + Должен иметь следующие поля:
        + `(#) tasks: Task[]` - список всех задач
    + Должен иметь следующие методы:
        + `addTasks: (...Task[]) => undefined` - Добавляет в `(#) tasks` только уникальные по `id` задачи
        + `deleteTask: (Task) => undefined` - Удаляет задачу из списка
        + `getTasks: () => Task[]` - возвращает массив всех задач
        + `getTasksSortedBy: (string) => Task[]`
            + принимает на вход строку, которая может иметь один из 3-х значений:
                + `'description'` - в алфавитном порядке
                + `'status'` - сначала сделанные
                + `'cost'` - по убыванию стоимости
            + Возвращает отсортированный массив
        + `getFilteredTasks: (object) => Task[]`
            + принимает на вход объект с возможными (какие-то (не все) из перечисленных полей могут отсутствовать) 
              полями:
                + `description?: string` - оставляет задачи, которые в `description` содержат переданное значение
                + `isIncome?: boolean`
                    + `true` - оставляет задачи, которые `IncomeTask`
                    + `false` - оставляет задачи, которые `ExpenseTask`
                + `isCompleted?: boolean`
	                + `true` - оставляет задачи, которые сделаны
	                + `false` - оставляет задачи, которые не сделаны
            + возвращает массив с отфильтрованными, по всем переданным полям, задачами
    + Должен иметь механизм работы с уже сделанными задачами (понадобится в `BudgetController` в `doneTask` и
      `unDoneTask`)


+ Класс `BudgetController`
    + Должен иметь следующие поля:
        + `(#) tasksController: TasksController`. Все действия связанные с множеством задач должны 
          происходить с помощью вызова методов у этого экземпляра
        + `(#) budget: object`
            + `balance: number` - начальный баланс
            + `income: number` - сумма всей прибыли
            + `expenses: number` - сумма всех расходов
    + При создании:
        + на вход принимает 1 аргумент, который отвечает за начальный баланс. Если ничего не передано, то `0`
        + создаёт экземпляр `TasksController` и записывает в поле `(#) tasksController`
    + Должен иметь следующие геттеры:
        + `balance: () => number`
        + `income: () => number`
        + `expenses: () => number`
    + Должен иметь следующие методы:
        + `calculateBalance: () => number` - возвращает оставшуюся сумму с учётом прибыли и расходов
        + `getTasks: () => Task[]` - возвращает массив всех задач, вызовом метода `getTasks` у `(#) tasksController` 
        + `addTasks: (...Task[]) => undefined`
            + вызывает метод `addTasks` у `(#) tasksController` и отправляет все задачи ему на вход
            + ЗАПРЕЩЕНО где-либо хранить множество задач, кроме как внутри `(#) tasksController` 
        + `deleteTask: (Task) => undefined`
            + Если такой задачи не было в списке, то выводит в консоль
              сообщение типа: `Task ${task.id} isn't recognized` и на этом завершает свою работу
            + Если такая задача была проделана, то вызывает у неё метод `makeUnDone`
            + Вызывает метод `deleteTask` у `(#) tasksController`
        + `doneTask: (Task) => undefined`
            + Если такой задачи не было в списке, то выводит в консоль
              сообщение типа: `Task ${task.id} isn't recognized` и на этом завершает свою работу
            + Если задача была сделана ранее, то выводит в консоль сообщение типа: `'Task is already done'` и на 
              этом завершает свою работу
            + Вызывает метод `makeDone` у задачи
        + `unDoneTask: (Task) => undefined`
            + Если такой задачи не было в списке, то выводит в консоль
              сообщение типа: `Task ${task.id} isn't recognized` и на этом завершает свою работу
            + Если задача не была сделана ранее, то выводит в консоль сообщение типа: `'Task isn't done before'` и 
              на этом завершает свою работу
            + Вызывает метод `makeUnDone` у задачи


+ Все названия переменных/классов/методов/функций должны быть понятны и отображать суть содержимого


+ Разрешено добавлять свои методы/классы/поля/функции/переменные, но вы должны быть уверены, что при попытке
  взаимодействия с дополнительными вещами программа не ломается


+ Можете использовать JSDocs, если есть желание, но всегда нужно помнить, что это будет просто комментарием для вас,
  чтобы избежать очевидных ошибок, чтобы были правильные подсказки у IDE и т.д.